# 스트리밍 데이터에서 상위 K번째 원소 선택 알고리즘 비교

스트리밍 데이터는 모든 데이터를 메모리에 한 번에 저장할 수 없는 특성이 있어 일반적인 선택 알고리즘과는 다른 접근이 필요합니다. 아래는 이러한 환경에서 상위 K번째 원소를 선택하는 알고리즘들을 비교한 것입니다.

| 알고리즘 | 시간복잡도 | 공간복잡도 | 특징 |
|---------|-----------|-----------|------|
| **Bounded Priority Queue (Heap)** **(★★)** | O(n log k) | O(k) | 크기 k인 최소 힙을 유지, 스트리밍에 최적화 |
| **Reservoir Sampling** | O(n) | O(k) | 균등한 확률로 k개 샘플 선택, 정확한 순위는 모름 |
| **Count-Min Sketch** **(★)** | O(n) | O(log(n)·log(1/δ)) | 근사적 빈도 계산, 메모리 효율적 |
| **Space Saving Algorithm** **(★)** | O(n log k) | O(k) | 빈도 기반 상위 k 요소 추적, 카운터 유지 |
| **Lossy Counting** | O(n) | O(1/ε·log(εn)) | 근사 빈도 계산, 오차 범위 ε 설정 가능 |
| **Sliding Window** | O(n log w) | O(w) | 최근 w개 요소만 고려, 시간 변화 반영 |
| **Exponential Histogram** | O(n log(log n)) | O(log n · log(1/ε)) | 시간 가중치 적용, 오래된 데이터 지수적 감소 |

## 각 알고리즘 특징 및 차이점

### 1. Bounded Priority Queue (Heap) **(★★)**
- **원리**: 크기 k인 최소 힙을 유지하면서 새로운 요소가 힙의 최솟값보다 크면 교체
- **장점**: 메모리 사용량 일정(O(k)), 정확한 상위 k개 요소 유지
- **단점**: 데이터 스트림이 매우 클 때 요소별 log(k) 연산 비용
- **적합한 상황**: 정확한 상위 k개 요소가 필요하고 k가 작을 때

### 2. Reservoir Sampling
- **원리**: 처음 k개 요소를 저장한 후, 확률적으로 새 요소와 교체
- **장점**: 스트림 크기를 모르는 환경에서도 균등한 샘플링 가능
- **단점**: 정확한 상위 k개가 아닌 랜덤 샘플링, 순위 정보 유지 불가
- **적합한 상황**: 스트림에서 대표 샘플이 필요할 때 (정확한 순위가 중요하지 않은 경우)

### 3. Count-Min Sketch **(★)**
- **원리**: 해시 함수와 카운터를 사용한 빈도 추정 자료구조
- **장점**: 메모리 효율적, 큰 데이터에 적합, 빠른 업데이트
- **단점**: 정확한 순위가 아닌 근사값, 해시 충돌로 인한 오차
- **적합한 상황**: 대략적인 빈도 계산이 필요한 대용량 스트림

### 4. Space Saving Algorithm **(★)**
- **원리**: k개의 (요소, 카운터) 쌍을 유지하고 새 요소 등장 시 카운터 조정
- **장점**: 메모리 효율적, 빈도 기반 상위 k개 요소 정확히 추적
- **단점**: 정확한 카운트가 아닐 수 있음, 새로운 요소에 불리
- **적합한 상황**: 빈도 기반 상위 k개 항목이 필요할 때

### 5. Lossy Counting
- **원리**: 데이터를 윈도우로 나누고 각 윈도우마다 카운터 관리
- **장점**: 설정 가능한 오차 범위, 메모리와 정확도 균형
- **단점**: 구현 복잡, 매개변수 튜닝 필요
- **적합한 상황**: 메모리 제약이 심하고 근사치가 허용되는 경우

### 6. Sliding Window
- **원리**: 최근 w개 요소만 고려하는 윈도우 유지
- **장점**: 시간 변화 반영, 최신 데이터에 초점
- **단점**: 고정 크기 메모리 필요, 윈도우 이전 정보 손실
- **적합한 상황**: 최근 데이터에 가중치를 두어야 하는 실시간 분석

### 7. Exponential Histogram
- **원리**: 시간에 따라 지수적으로 데이터 해상도 감소
- **장점**: 과거 데이터 요약 유지, 시간 감쇠 반영
- **단점**: 복잡한 구현, 정확한 순위보다 트렌드 파악에 적합
- **적합한 상황**: 오래된 데이터의 요약 통계가 필요한 장기 분석

## 알고리즘 선택 가이드

- **정확한 상위 k개 요소가 필요할 때**: Bounded Priority Queue (Heap) **(★★)**
- **메모리가 매우 제한적일 때**: Count-Min Sketch **(★)** 또는 Lossy Counting
- **빈도 기반 인기 항목이 필요할 때**: Space Saving Algorithm **(★)**
- **최근 데이터에 가중치를 둘 때**: Sliding Window
- **대용량 스트림에서 균등한 샘플이 필요할 때**: Reservoir Sampling
- **장기간 트렌드 분석이 필요할 때**: Exponential Histogram

코딩테스트나 실제 응용에서는 Bounded Priority Queue가 간단하면서도 효과적인 구현으로 가장 많이 사용됩니다. 메모리 효율성이 중요한 대규모 시스템에서는 Count-Min Sketch와 Space Saving Algorithm이 자주 활용됩니다.