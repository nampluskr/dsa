DFS의 경우, 방문 순서의 기록(탐색 순서 경로)과 parent 배열로 재구성한 경로가 일치하는 이유는 DFS의 동작 방식과 구현된 코드의 특성에 있습니다.

### 주요 이유

1. **백트래킹 구현**: 
   코드에서 구현된 DFS는 목표 노드를 찾지 못하면 경로에서 노드를 제거하는 백트래킹 로직을 포함하고 있습니다.
   ```cpp
   // 목표 노드를 찾지 못하면 현재 노드를 경로에서 제거 (백트래킹)
   path.pop_back();
   ```

2. **탐색 중단**: 
   목표 노드를 찾는 즉시 탐색을 중단하고 true를 반환합니다. 더 이상의 노드 탐색이나 백트래킹이 발생하지 않습니다.
   ```cpp
   if (curr == target) return true;
   ```

3. **깊이 우선 특성**: 
   DFS는 한 경로를 끝까지 탐색한 후 다른 경로를 탐색합니다. 목표 노드를 찾는 즉시 탐색이 중단되므로, path에는 시작 노드에서 목표 노드까지의 첫 번째 발견 경로만 남게 됩니다.

### 예시 설명

예를 들어, 코드에서 사용된 그래프에서 0(시작) → 2 → 5 → 7 → 8(목표) 경로를 통해 목표 노드를 찾는다고 가정해보겠습니다:

1. DFS 탐색 순서: 
   - 0 방문 → 1 방문 → 3 방문 (목표 아님) → 3 탐색 완료 → 4 방문 (목표 아님) → 4 탐색 완료 → 1 탐색 완료 → 2 방문 → 5 방문 → 7 방문 → 8 방문 (목표 도달!)

2. 백트래킹으로 인한 최종 path: 
   - 0 → 2 → 5 → 7 → 8
   - 1, 3, 4와 같이 목표 노드로 이어지지 않는 경로의 노드들은 백트래킹으로 인해 path에서 제거됩니다.

3. parent 배열: 
   - parent[8] = 7
   - parent[7] = 5
   - parent[5] = 2
   - parent[2] = 0
   - 이를 바탕으로 재구성한 경로: 0 → 2 → 5 → 7 → 8

결국 백트래킹을 통해 정제된 path와 parent 배열로 재구성한 경로는 동일하게 됩니다.

### BFS와의 차이점

BFS의 경우는 다릅니다. BFS는 모든 인접 노드를 레벨 순서로 탐색하기 때문에:

1. 탐색 순서 경로(path)에는 시작 노드부터 레벨별로 방문한 모든 노드가 포함됩니다.
2. parent 배열로 재구성한 경로는 시작 노드에서 목표 노드까지의 최단 경로만 포함합니다.

따라서 BFS에서는 두 경로가 일반적으로 일치하지 않습니다.